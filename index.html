<html><!-- Copyright (C) Eric Schulte 2013, License GPLV3 --><head><title>evolve polygons to match images</title></head><body onload='setup();'><table><tr><th>target image</th><th>current </th></tr><tr><td><canvas id='target' onclick='setImage();'></canvas></td><td><canvas id='current' onclick='getBest();'></canvas></td></tr></table><table><tr><th>Actions</th><td><a href='#' onclick='evolve();'>EVOLVE</a> <a href='#' onclick='mcmc();'>MCMC</a> <a href='#' onclick='stop();'>STOP</a> <a href='#' onclick='showBest();'>SHOW-BEST</a> <a href='#' onclick='loadPolygon();'>LOAD-POLYGON</a> </td></tr><tr><th>Parameters</th><td><a href='#' onclick='maxLength();'>MAX-LENGTH</a> <a href='#' onclick='maxVerts();'>MAX-VERTS</a> <a href='#' onclick='popSize();'>POP-SIZE</a> <a href='#' onclick='tournamentSize();'>TOURNAMENT-SIZE</a> <a href='#' onclick='delay();'>DELAY</a> </td></tr><tr><th>best</th><td id='best'>no js</td></tr><tr><th>mean</th><td id='mean'>no js</td></tr><tr><th>evals</th><td id='evals'>no js</td></tr><tr><th>length</th><td id='length'>no js</td></tr></table><script type='text/javascript'>var img = new Image();
var width = null;
var height = null;
function setup() {
    stats();
    setInterval(stats, 1000);
    var write = function (id, text) {
        var x = document.getElementById(id).getContext("2d");
        x.fillStyle = "black";
        x.font = "12pt Arial";
        return x.fillText(text, 80, 60);
    };
    var image = /image=([^&#]*)/.exec(location.search);
    var poly = /polygon=([^&#]*)/.exec(location.search);
    if (image == null) {
        write("target", "click to set image");
    } else {
        setImage(decodeURIComponent(image[1]));
    };
    return poly == null ? write("current", "click to get polygons") : loadPolygon(decodeURIComponent(poly[1]));
};
function setImage(url, cb) {
    var canvas = document.getElementById("target");
    var current = document.getElementById("current");
    img = new Image();
    img.onload = function () {
        canvas.width = img.width;
        canvas.height = img.height;
        current.width = img.width;
        current.height = img.height;
        width = img.width;
        height = img.height;
        canvas.getContext("2d").drawImage(img, 0, 0);
        return cb ? cb() : null;
    };
    img.onerror = function () {
        return alert("server at " + img.src + " does not support CORS");
    };
    img.crossOrigin = "anonymous";
    return img.src = url || prompt("enter an image url (from a CORS enabled server)", "./images/mona-lisa.png");
};
function loadPolygon(data) {
    var data27 = data || prompt("paste in the JSON of a polygon");
    if (data27 != null) {
        var individual = JSON.parse(data27);
        return setImage(individual["url"], function () {
            evaluate(individual);
            stop();
            clear();
            individual["genome"].map(draw);
            return window.pop.sort(fitSort).splice(-1, 1, individual);
        });
    };
};
function clear() {
    return document.getElementById("current").getContext("2d").clearRect(0, 0, width, height);
};
function drawColor(c) {
    return "rgba(" + c[0] + ", " + c[1] + ", " + c[2] + ", " + c[3] + ")";
};
function draw(poly) {
    var points = poly["vertices"].slice(0);
    var head = points.pop;
    var cx = document.getElementById("current").getContext("2d");
    cx.fillStyle = drawColor(poly["color"]);
    cx.beginPath();
    cx.moveTo(head[0], head[1]);
    points.map(function (point) {
        return cx.lineTo(point[0], point[1]);
    });
    cx.closePath();
    return cx.fill();
};
function data(id) {
    try {
        return document.getElementById(id).getContext("2d").getImageData(0, 0, width, height).data;
    } catch (e) {
        return alert("no image data set");
    };
};
function score() {
    var dc = data("current");
    var dt = dc ? data("target") : null;
    return (function () {
        var _js28 = dc.length;
        var sum29 = 0;
        for (var i = 0; i < _js28; i += 1) {
            sum29 += Math.abs(dc[i] - dt[i]);
        };
        return sum29;
    })();
};
function addPoly() {
    return draw(poly());
};
function addInd() {
    return evaluate(newInd());
};
var evals = 0;
var softGenomeLength = 128;
var maxPolyLength = 4;
var maxGenomeStartLength = 32;
function compose() {
    return [];
};
function randomInd(list) {
    return Math.floor(list.length * Math.random());
};
function randomElt(list) {
    return list[randomInd(list)];
};
function point() {
    return [Math.floor(width * Math.random()), Math.floor(height * Math.random())];
};
function randomColor() {
    return [Math.floor(256 * Math.random()), Math.floor(256 * Math.random()), Math.floor(256 * Math.random()), Math.floor(100 * Math.random()) / 100];
};
function poly() {
    var RAND30;
    var orig;
    var range;
    var flex;
    return { color : randomColor(), vertices : (RAND30 = Math.random(), RAND30 < 0.5 ? (function () {
        var _js31 = Math.floor(maxPolyLength * Math.random());
        var collect32 = [];
        for (var i = 0; i <= _js31; i += 1) {
            collect32["push"](point());
        };
        return collect32;
    })() : (orig = point(), range = Math.random() * Math.min(width, height), (flex = function (pt, b) {
        return Math.max(0, Math.min(pt + (2 * Math.random() * range - range), b));
    }, (function () {
        var _js33 = Math.floor(maxPolyLength * Math.random());
        var collect34 = [];
        for (var i = 0; i <= _js33; i += 1) {
            collect34["push"]([flex(orig[1], width), flex(orig[1], height)]);
        };
        return collect34;
    })()))) };
};
function genome() {
    return (function () {
        var _js35 = Math.floor(maxGenomeStartLength * Math.random());
        var collect36 = [];
        for (var i = 0; i <= _js35; i += 1) {
            collect36["push"](poly());
        };
        return collect36;
    })();
};
function newInd() {
    return { fit : null, genome : genome() };
};
function copyPoly(poly) {
    return { color : poly["color"].slice(0), vertices : poly["vertices"].map(function (v) {
        return v.slice(0);
    }) };
};
function copyInd(ind) {
    return { fit : null, genome : ind["genome"].map(copyPoly) };
};
function evaluate(ind) {
    ++evals;
    clear();
    ind["genome"].map(draw);
    ind["fit"] = score() * (Math.max(softGenomeLength, ind["genome"].length) / softGenomeLength);
    return ind;
};
function crossover(a, b) {
    var pt = Math.min(a["genome"].length, b["genome"].length);
    return { fit : null, genome : a["genome"].slice(0, pt).map(copyPoly).concat(b["genome"].slice(pt).map(copyPoly)) };
};
function tweakRange(n, range) {
    var RAND37 = Math.random();
    if (RAND37 < 0.5) {
        return Math.min(n + Math.floor((n / 8) * Math.random()), range);
    } else {
        return Math.max(n - Math.floor((n / 8) * Math.random()), 0);
    };
};
function tweakPoly(poly) {
    var RAND38 = Math.random();
    if (RAND38 < 0.5) {
        var vert = randomElt(poly["vertices"]);
        var RAND39 = Math.random();
        if (RAND39 < 0.5) {
            return vert[0] = tweakRange(vert[0], width);
        } else {
            return vert[1] = tweakRange(vert[1], height);
        };
    } else {
        var pt = Math.floor(4 * Math.random());
        return poly["color"][4] = pt === 3 ? tweakRange(100 * poly["color"][pt], 100) / 100 : tweakRange(poly["color"][pt], 255);
    };
};
function mutate(ind) {
    var g = ind["genome"];
    var i = randomInd(g);
    var RAND40 = Math.random();
    if (RAND40 < 0.25) {
        if (g.length > 1) {
            g.splice(i, 1);
        };
    } else if (RAND40 < 0.5) {
        g.splice(i, 0, poly());
    } else if (RAND40 < 0.75) {
        tweakPoly(g[i]);
    } else {
        var j = randomInd(g);
        var cp = copyPoly(g[i]);
        var pc = copyPoly(g[j]);
        g.splice(i, 1, pc);
        g.splice(j, 1, cp);
    };
    return ind;
};
var running = true;
var pop = new Array();
var pSize = 128;
var tSize = 2;
var throttle = 2;
function maxLength() {
    var newMax = prompt("soft genome length limit:", softGenomeLength);
    if (newMax != null) {
        softGenomeLength = parseInt(newMax, 10);
        return window.pop.map(evaluate);
    };
};
function maxVerts() {
    var max = prompt("maximum number of polygon vertices:", maxPolyLength);
    return max != null ? (maxPolyLength = max) : null;
};
function popSize() {
    var oldSize = pSize;
    var newSize = prompt("population size:", pSize);
    if (newSize != null) {
        pSize = parseInt(newSize, 10);
        if (oldSize > pSize) {
            return window.pop.splice(pSize);
        } else {
            var _js43 = pSize - oldSize;
            for (var i = 0; i < _js43; i += 1) {
                window.pop.push(evaluate(newInd()));
            };
        };
    };
};
function tournamentSize() {
    var newT = prompt("tournament size:", tSize);
    return newT != null ? (tSize = parseInt(newT, 10)) : null;
};
function delay() {
    var newD = prompt("delay between evaluations (millis):", throttle);
    return newD != null ? (throttle = parseInt(newD, 10)) : null;
};
function fitSort(a, b) {
    return a["fit"] - b["fit"];
};
function mean(l) {
    return (function () {
        var _js45 = l.length;
        var sum46 = 0;
        for (var _js44 = 0; _js44 < _js45; _js44 += 1) {
            var el = l[_js44];
            sum46 += el;
        };
        return sum46;
    })() / l.length;
};
function meanLength() {
    return mean(window.pop.map(function (it) {
        return it["genome"].length;
    }));
};
function tournament() {
    return (function () {
        var collect47 = [];
        for (var i = 1; i <= tSize; i += 1) {
            collect47["push"](randomElt(window.pop));
        };
        return collect47;
    })().sort(fitSort)[0];
};
function popHelper(n) {
    if (running && n > 0) {
        window.pop.push(evaluate(newInd()));
        return setTimeout(function () {
            return popHelper(n - 1);
        }, throttle);
    } else {
        return setTimeout(evolveHelper, throttle);
    };
};
function evolveHelper() {
    var RAND48;
    if (running) {
        window.pop.sort(fitSort).splice(-1, 1, evaluate(mutate((RAND48 = Math.random(), RAND48 < 0.5 ? copyInd(tournament()) : crossover(tournament(), tournament())))));
        return setTimeout(evolveHelper, throttle);
    };
};
function evolve() {
    running = true;
    return pSize > window.pop.length ? setTimeout(function () {
        return popHelper(pSize - window.pop.length);
    }, throttle) : setTimeout(evolveHelper, throttle);
};
function mcmcHelper() {
    if (running) {
        var oldFit = window.pop[0]["fit"];
        var newInd = evaluate(mutate(copyInd(window.pop[0])));
        var newFit = newInd["fit"];
        if (newFit < oldFit || Math.random() < oldFit / newFit && ((window.pop[1] == null || oldFit < window.pop[1]["fit"]) && (window.pop[1] = window.pop[0]) || true)) {
            window.pop[0] = newInd;
        };
        return setTimeout(mcmcHelper, throttle);
    };
};
function mcmc() {
    if (window.pop[0] == null) {
        window.pop[0] = evaluate(newInd());
    };
    window.pop.sort(fitSort).splice(1);
    pSize = 1;
    running = true;
    return mcmcHelper();
};
function stats() {
    var scores = window.pop.sort(fitSort).map(function (it) {
        return it["fit"];
    });
    document.getElementById("evals").innerHTML = evals;
    document.getElementById("best").innerHTML = scores[0];
    document.getElementById("mean").innerHTML = mean(scores);
    document.getElementById("length").innerHTML = meanLength();
    return scores;
};
function stop() {
    return running = false;
};
function best() {
    return window.pop.sort(fitSort)[0];
};
function showBest() {
    stop();
    clear();
    return best()["genome"].map(draw);
};
function getBest() {
    var best49 = best();
    var pre = "data:text/JSON;base64,";
    var _js50 = [["url", img.src], ["evals", evals], ["tournament-size", tSize], ["pop-size", pSize], ["max-verts", maxPolyLength], ["max-length", softGenomeLength]];
    var _js52 = _js50.length;
    for (var _js51 = 0; _js51 < _js52; _js51 += 1) {
        var _db53 = _js50[_js51];
        var key = _db53[0];
        var val = _db53[1];
        best49[key] = val;
    };
    return window.open(pre + btoa(JSON.stringify(best49)));
};</script></body></html>